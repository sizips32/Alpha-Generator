# ì•ŒíŒŒ íŒ©í„° ìƒì„±ê¸° v2.0 ê¸°ìˆ  ë¬¸ì„œ

## ëª©ì°¨
1. [ì•„í‚¤í…ì²˜ ê°œìš”](#ì•„í‚¤í…ì²˜-ê°œìš”)
2. [ëª¨ë“ˆ ìƒì„¸ ì„¤ëª…](#ëª¨ë“ˆ-ìƒì„¸-ì„¤ëª…)
3. [API ì°¸ì¡°](#api-ì°¸ì¡°)
4. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
5. [ë³´ì•ˆ ê³ ë ¤ì‚¬í•­](#ë³´ì•ˆ-ê³ ë ¤ì‚¬í•­)
6. [í™•ì¥ ê°€ì´ë“œ](#í™•ì¥-ê°€ì´ë“œ)

## ì•„í‚¤í…ì²˜ ê°œìš”

### ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°
```
alpha_factor_generator_v2/
â”œâ”€â”€ app.py                 # ë©”ì¸ Streamlit ì• í”Œë¦¬ì¼€ì´ì…˜
â”œâ”€â”€ src/                   # í•µì‹¬ ëª¨ë“ˆë“¤
â”‚   â”œâ”€â”€ data_manager.py    # ë°ì´í„° ê´€ë¦¬ ëª¨ë“ˆ
â”‚   â”œâ”€â”€ factor_engine.py   # íŒ©í„° ìƒì„± ë° ë¶„ì„ ì—”ì§„
â”‚   â”œâ”€â”€ backtest_engine.py # ë°±í…ŒìŠ¤íŒ… ì—”ì§„
â”‚   â””â”€â”€ ai_engine.py       # AI ì¶”ì²œ ì‹œìŠ¤í…œ
â”œâ”€â”€ data/                  # ë°ì´í„° ì €ì¥ì†Œ
â”‚   â””â”€â”€ cache/            # ìºì‹œ ë””ë ‰í† ë¦¬
â”œâ”€â”€ config/               # ì„¤ì • íŒŒì¼ë“¤
â”œâ”€â”€ tests/                # í…ŒìŠ¤íŠ¸ íŒŒì¼ë“¤
â””â”€â”€ docs/                 # ë¬¸ì„œë“¤
```

### ë°ì´í„° í”Œë¡œìš°
```
[ì™¸ë¶€ ë°ì´í„°] â†’ [ë°ì´í„° ë§¤ë‹ˆì €] â†’ [íŒ©í„° ì—”ì§„] â†’ [ë°±í…ŒìŠ¤íŒ…] â†’ [ê²°ê³¼ ì‹œê°í™”]
     â†‘              â†“              â†‘
[AI ì¶”ì²œ ì‹œìŠ¤í…œ] â† [ì‚¬ìš©ì ì…ë ¥] â†’ [íŒ©í„° ë™ë¬¼ì›]
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™
1. **ëª¨ë“ˆí™”**: ê° ê¸°ëŠ¥ì´ ë…ë¦½ì ì¸ ëª¨ë“ˆë¡œ ë¶„ë¦¬
2. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ë°ì´í„° ì†ŒìŠ¤ë‚˜ íŒ©í„° ì¶”ê°€ ìš©ì´
3. **ì•ˆì „ì„±**: ì‚¬ìš©ì ì…ë ¥ì— ëŒ€í•œ ì² ì €í•œ ê²€ì¦
4. **ì„±ëŠ¥**: ìºì‹±ê³¼ ìµœì í™”ë¥¼ í†µí•œ ë¹ ë¥¸ ì‘ë‹µ
5. **ì‚¬ìš©ì„±**: ì§ê´€ì ì¸ UIì™€ ëª…í™•í•œ í”¼ë“œë°±

## ëª¨ë“ˆ ìƒì„¸ ì„¤ëª…

### 1. ë°ì´í„° ë§¤ë‹ˆì € (data_manager.py)

#### ì£¼ìš” ê¸°ëŠ¥
- ì‹¤ì‹œê°„ ì£¼ì‹ ë°ì´í„° ìˆ˜ì§‘ (Yahoo Finance API)
- ê¸°ìˆ ì  ì§€í‘œ ìë™ ê³„ì‚°
- ê¸°ë³¸ì  ë¶„ì„ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
- ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬ ë° ìºì‹±

#### í•µì‹¬ í´ë˜ìŠ¤: DataManager
```python
class DataManager:
    def __init__(self, cache_dir: str = "data/cache")
    def get_stock_data(self, symbols: List[str], period: str = "2y") -> pd.DataFrame
    def add_technical_indicators(self, df: pd.DataFrame) -> pd.DataFrame
    def add_fundamental_data(self, df: pd.DataFrame) -> pd.DataFrame
    def clean_data(self, df: pd.DataFrame) -> pd.DataFrame
```

#### ì§€ì›í•˜ëŠ” ê¸°ìˆ ì  ì§€í‘œ
- **ì¶”ì„¸ ì§€í‘œ**: SMA, EMA, MACD
- **ëª¨ë©˜í…€ ì§€í‘œ**: RSI, Stochastic
- **ë³€ë™ì„± ì§€í‘œ**: Bollinger Bands, ATR
- **ê±°ë˜ëŸ‰ ì§€í‘œ**: OBV, Volume SMA

#### ìºì‹± ë©”ì»¤ë‹ˆì¦˜
- íŒŒì¼ ê¸°ë°˜ ìºì‹± (pickle í˜•íƒœ)
- 1ì‹œê°„ TTL (Time To Live)
- ìë™ ìºì‹œ ë¬´íš¨í™”

### 2. íŒ©í„° ì—”ì§„ (factor_engine.py)

#### ì£¼ìš” ê¸°ëŠ¥
- ì•ˆì „í•œ ìˆ˜ì‹ ê¸°ë°˜ íŒ©í„° ìƒì„±
- ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ íŒ©í„° ìƒì„±
- íŒ©í„° ì„±ê³¼ ë¶„ì„ ë° í†µê³„ ê³„ì‚°

#### í•µì‹¬ í´ë˜ìŠ¤ë“¤

##### SafeExpressionEvaluator
```python
class SafeExpressionEvaluator:
    def __init__(self, allowed_names: List[str])
    def evaluate(self, expression: str, data: Dict[str, Any]) -> np.ndarray
```

**ë³´ì•ˆ íŠ¹ì§•:**
- AST(Abstract Syntax Tree) ê¸°ë°˜ íŒŒì‹±
- í—ˆìš©ëœ ì—°ì‚°ì/í•¨ìˆ˜ë§Œ ì‹¤í–‰
- Import, Exec, Eval êµ¬ë¬¸ ì°¨ë‹¨

##### FactorGenerator
```python
class FactorGenerator:
    def create_formula_factor(self, data: pd.DataFrame, formula: str, factor_name: str) -> pd.Series
    def create_ml_factor(self, data: pd.DataFrame, target_col: str, method: str, factor_name: str) -> pd.Series
```

**ì§€ì›í•˜ëŠ” ML ë°©ë²•:**
- Random Forest: í”¼ì²˜ ì¤‘ìš”ë„ ê¸°ë°˜ ì¡°í•©
- MLP: ì‹ ê²½ë§ ê¸°ë°˜ ì ì¬ íŒ©í„°
- PCA: ì£¼ì„±ë¶„ ë¶„ì„
- XGBoost: ê·¸ë˜ë””ì–¸íŠ¸ ë¶€ìŠ¤íŒ…

##### FactorAnalyzer
```python
class FactorAnalyzer:
    def calculate_ic(self, factor: pd.Series, returns: pd.Series) -> float
    def calculate_icir(self, factor: pd.Series, returns: pd.Series) -> float
    def calculate_factor_stats(self, factor: pd.Series, returns: pd.Series) -> Dict[str, float]
```

**ê³„ì‚°í•˜ëŠ” í†µê³„:**
- IC (Information Coefficient): íŒ©í„°ì™€ ìˆ˜ìµë¥  ê°„ ìƒê´€ê´€ê³„
- ICIR (IC Information Ratio): ICì˜ ì•ˆì •ì„± ì§€í‘œ
- ê¸°ë³¸ í†µê³„: í‰ê· , í‘œì¤€í¸ì°¨, ì™œë„, ì²¨ë„
- ë¶„í¬ í†µê³„: ë¶„ìœ„ìˆ˜, ê²°ì¸¡ì¹˜ ë¹„ìœ¨

### 3. ë°±í…ŒìŠ¤íŒ… ì—”ì§„ (backtest_engine.py)

#### ì£¼ìš” ê¸°ëŠ¥
- íŒ©í„° ê¸°ë°˜ í¬íŠ¸í´ë¦¬ì˜¤ ë°±í…ŒìŠ¤íŒ…
- ì„±ê³¼ ì§€í‘œ ê³„ì‚°
- ë²¤ì¹˜ë§ˆí¬ ë¹„êµ
- ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸ ìƒì„±

#### í•µì‹¬ í´ë˜ìŠ¤: BacktestEngine
```python
class BacktestEngine:
    def run_factor_backtest(self, factor_data: pd.Series, price_data: pd.DataFrame, 
                           rebalance_freq: str = 'M', long_short: bool = True) -> Dict
    def create_performance_chart(self, backtest_result: Dict) -> go.Figure
```

#### ë°±í…ŒìŠ¤íŒ… í”„ë¡œì„¸ìŠ¤
1. **í¬ì§€ì…˜ ê²°ì •**: íŒ©í„° ê°’ì— ë”°ë¥¸ ë¡±/ìˆ í¬ì§€ì…˜ ê³„ì‚°
2. **ë¦¬ë°¸ëŸ°ì‹±**: ì„¤ì •ëœ ì£¼ê¸°ì— ë”°ë¥¸ í¬íŠ¸í´ë¦¬ì˜¤ ì¬êµ¬ì„±
3. **ìˆ˜ìµë¥  ê³„ì‚°**: ê±°ë˜ë¹„ìš©ì„ ê³ ë ¤í•œ ì¼ë³„ ìˆ˜ìµë¥ 
4. **ì„±ê³¼ ë¶„ì„**: ë‹¤ì–‘í•œ ë¦¬ìŠ¤í¬ ì¡°ì • ì§€í‘œ ê³„ì‚°

#### ê³„ì‚°í•˜ëŠ” ì„±ê³¼ ì§€í‘œ
- **ìˆ˜ìµë¥  ì§€í‘œ**: ì´ìˆ˜ìµë¥ , ì—°ê°„ìˆ˜ìµë¥ 
- **ë¦¬ìŠ¤í¬ ì§€í‘œ**: ë³€ë™ì„±, ìµœëŒ€ë‚™í­
- **ë¦¬ìŠ¤í¬ ì¡°ì • ì§€í‘œ**: ìƒ¤í”„ë¹„ìœ¨, ì¹¼ë§ˆë¹„ìœ¨
- **ë¶„í¬ ì§€í‘œ**: ìŠ¹ë¥ , ì™œë„, ì²¨ë„

### 4. AI ì—”ì§„ (ai_engine.py)

#### ì£¼ìš” ê¸°ëŠ¥
- Gemini API ê¸°ë°˜ íˆ¬ì ì•„ì´ë””ì–´ ë¶„ì„
- ë§ì¶¤í˜• íŒ©í„° ì¶”ì²œ
- ìœ„í—˜ë„ë³„ ì „ëµ ì œì•ˆ

#### í•µì‹¬ í´ë˜ìŠ¤: AIRecommendationEngine
```python
class AIRecommendationEngine:
    def __init__(self, api_key: Optional[str] = None)
    def generate_factor_recommendations(self, user_idea: str, market_context: Optional[str] = None, 
                                      risk_preference: str = 'medium') -> Dict[str, Any]
```

#### ì¶”ì²œ ì‹œìŠ¤í…œ êµ¬ì¡°
1. **í”„ë¡¬í”„íŠ¸ ìƒì„±**: ì‚¬ìš©ì ì…ë ¥ì„ êµ¬ì¡°í™”ëœ í”„ë¡¬í”„íŠ¸ë¡œ ë³€í™˜
2. **API í˜¸ì¶œ**: Gemini Pro ëª¨ë¸ì„ í†µí•œ ë¶„ì„
3. **ê²°ê³¼ íŒŒì‹±**: JSON í˜•íƒœì˜ êµ¬ì¡°í™”ëœ ì¶”ì²œ ê²°ê³¼
4. **ê²€ì¦ ë° ë³´ì™„**: ì¶”ì²œ ê²°ê³¼ì˜ ìœ íš¨ì„± ê²€ì‚¬ ë° ê¸°ë³¸ê°’ ë³´ì™„

#### íŒ©í„° ì¹´í…Œê³ ë¦¬
- **ëª¨ë©˜í…€**: ìˆ˜ìµë¥ , ê°€ê²© ëª¨ë©˜í…€, RSI, MACD
- **ë°¸ë¥˜**: PER, PBR, ROE, ROA, ë°°ë‹¹ìˆ˜ìµë¥ 
- **í€„ë¦¬í‹°**: ë¶€ì±„ë¹„ìœ¨, ìœ ë™ë¹„ìœ¨, ì„±ì¥ë¥ 
- **ë³€ë™ì„±**: ë² íƒ€, í‘œì¤€í¸ì°¨, VIX
- **ê±°ë˜ëŸ‰**: ê±°ë˜ëŸ‰, íšŒì „ìœ¨, OBV
- **ê¸°ìˆ ì **: ì´ë™í‰ê· , ë³¼ë¦°ì €ë°´ë“œ, ATR

## API ì°¸ì¡°

### ë°ì´í„° ë§¤ë‹ˆì € API

#### get_stock_data()
```python
def get_stock_data(self, symbols: List[str], period: str = "2y", 
                  interval: str = "1d", use_cache: bool = True) -> pd.DataFrame
```
**ë§¤ê°œë³€ìˆ˜:**
- `symbols`: ì£¼ì‹ ì‹¬ë³¼ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ['AAPL', 'GOOGL'])
- `period`: ë°ì´í„° ê¸°ê°„ (1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, ytd, max)
- `interval`: ë°ì´í„° ê°„ê²© (1m, 2m, 5m, 15m, 30m, 60m, 90m, 1h, 1d, 5d, 1wk, 1mo, 3mo)
- `use_cache`: ìºì‹œ ì‚¬ìš© ì—¬ë¶€

**ë°˜í™˜ê°’:** MultiIndex DataFrame (Date, Symbol)

#### add_technical_indicators()
```python
def add_technical_indicators(self, df: pd.DataFrame) -> pd.DataFrame
```
**ë§¤ê°œë³€ìˆ˜:**
- `df`: ê¸°ë³¸ OHLCV ë°ì´í„°

**ë°˜í™˜ê°’:** ê¸°ìˆ ì  ì§€í‘œê°€ ì¶”ê°€ëœ DataFrame

**ì¶”ê°€ë˜ëŠ” ì»¬ëŸ¼ë“¤:**
- Returns, Log_Returns
- SMA_20, SMA_50, EMA_12, EMA_26
- RSI, MACD, Stoch_K
- BB_Upper, BB_Middle, BB_Lower, ATR
- Volume_SMA, OBV
- High_Low_Ratio, Close_Open_Ratio

### íŒ©í„° ì—”ì§„ API

#### create_formula_factor()
```python
def create_formula_factor(self, data: pd.DataFrame, formula: str, factor_name: str) -> pd.Series
```
**ë§¤ê°œë³€ìˆ˜:**
- `data`: ì…ë ¥ ë°ì´í„° DataFrame
- `formula`: íŒ©í„° ìˆ˜ì‹ (ì˜ˆ: "Close / SMA_20")
- `factor_name`: íŒ©í„° ì´ë¦„

**ë°˜í™˜ê°’:** íŒ©í„° ê°’ Series

**ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ë“¤:**
- ê¸°ë³¸ ì—°ì‚°: +, -, *, /, **
- ìˆ˜í•™ í•¨ìˆ˜: abs, log, sqrt, exp, sin, cos, tan
- í†µê³„ í•¨ìˆ˜: mean, std, var, median, percentile
- ì‹œê³„ì—´ í•¨ìˆ˜: shift, rolling_mean, rolling_std, pct_change, rank

#### create_ml_factor()
```python
def create_ml_factor(self, data: pd.DataFrame, target_col: str, method: str, 
                    factor_name: str, feature_cols: Optional[List[str]] = None) -> pd.Series
```
**ë§¤ê°œë³€ìˆ˜:**
- `data`: ì…ë ¥ ë°ì´í„° DataFrame
- `target_col`: íƒ€ê²Ÿ ë³€ìˆ˜ ì»¬ëŸ¼ëª…
- `method`: ML ë°©ë²• ('rf', 'mlp', 'pca', 'xgb')
- `factor_name`: íŒ©í„° ì´ë¦„
- `feature_cols`: ì‚¬ìš©í•  í”¼ì²˜ ì»¬ëŸ¼ë“¤ (Noneì‹œ ìë™ ì„ íƒ)

**ë°˜í™˜ê°’:** ML ê¸°ë°˜ íŒ©í„° ê°’ Series

### ë°±í…ŒìŠ¤íŒ… ì—”ì§„ API

#### run_factor_backtest()
```python
def run_factor_backtest(self, factor_data: pd.Series, price_data: pd.DataFrame,
                       rebalance_freq: str = 'M', long_short: bool = True,
                       top_pct: float = 0.2, bottom_pct: float = 0.2,
                       transaction_cost: float = 0.001) -> Dict
```
**ë§¤ê°œë³€ìˆ˜:**
- `factor_data`: íŒ©í„° ê°’ Series (MultiIndex: Date, Symbol)
- `price_data`: ê°€ê²© ë°ì´í„° DataFrame (MultiIndex: Date, Symbol)
- `rebalance_freq`: ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸° ('D', 'W', 'M', 'Q')
- `long_short`: ë¡±ìˆ ì „ëµ ì—¬ë¶€
- `top_pct`: ìƒìœ„ í¼ì„¼íƒ€ì¼ (ë¡± í¬ì§€ì…˜)
- `bottom_pct`: í•˜ìœ„ í¼ì„¼íƒ€ì¼ (ìˆ í¬ì§€ì…˜)
- `transaction_cost`: ê±°ë˜ë¹„ìš© ë¹„ìœ¨

**ë°˜í™˜ê°’:** ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
```python
{
    'portfolio_returns': pd.DataFrame,     # í¬íŠ¸í´ë¦¬ì˜¤ ì¼ë³„ ìˆ˜ìµë¥ 
    'positions_history': List[Dict],       # í¬ì§€ì…˜ íˆìŠ¤í† ë¦¬
    'performance_metrics': Dict[str, float], # ì„±ê³¼ ì§€í‘œ
    'benchmark_returns': pd.DataFrame,     # ë²¤ì¹˜ë§ˆí¬ ìˆ˜ìµë¥ 
    'rebalance_dates': List[pd.Timestamp]  # ë¦¬ë°¸ëŸ°ì‹± ë‚ ì§œë“¤
}
```

### AI ì—”ì§„ API

#### generate_factor_recommendations()
```python
def generate_factor_recommendations(self, user_idea: str, market_context: Optional[str] = None,
                                  risk_preference: str = 'medium') -> Dict[str, Any]
```
**ë§¤ê°œë³€ìˆ˜:**
- `user_idea`: ì‚¬ìš©ì íˆ¬ì ì•„ì´ë””ì–´
- `market_context`: ì‹œì¥ ìƒí™© ì •ë³´ (ì„ íƒì‚¬í•­)
- `risk_preference`: ìœ„í—˜ ì„ í˜¸ë„ ('low', 'medium', 'high')

**ë°˜í™˜ê°’:** ì¶”ì²œ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
```python
{
    'analysis': str,                    # ì•„ì´ë””ì–´ ë¶„ì„ ê²°ê³¼
    'recommended_categories': List[str], # ì¶”ì²œ íŒ©í„° ì¹´í…Œê³ ë¦¬
    'features': List[Dict],             # ì¶”ì²œ í”¼ì²˜ë“¤
    'formulas': List[Dict],             # ì¶”ì²œ ìˆ˜ì‹ë“¤
    'ml_methods': List[Dict],           # ì¶”ì²œ ML ë°©ë²•ë“¤
    'risk_considerations': List[str],    # ìœ„í—˜ ê³ ë ¤ì‚¬í•­
    'implementation_tips': List[str]     # êµ¬í˜„ íŒë“¤
}
```


## ì„±ëŠ¥ ìµœì í™”

### ìºì‹± ì „ëµ

#### ë°ì´í„° ìºì‹±
- **íŒŒì¼ ê¸°ë°˜ ìºì‹±**: pickle í˜•íƒœë¡œ ë¡œì»¬ ì €ì¥
- **TTL ê´€ë¦¬**: 1ì‹œê°„ ìºì‹œ ìœ íš¨ì‹œê°„
- **ìë™ ë¬´íš¨í™”**: íŒŒì¼ ìˆ˜ì •ì‹œê°„ ê¸°ë°˜ ìºì‹œ ê°±ì‹ 

```python
# ìºì‹œ êµ¬í˜„ ì˜ˆì‹œ
cache_file = os.path.join(self.cache_dir, f"{cache_key}.pkl")
if use_cache and os.path.exists(cache_file):
    cache_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
    if datetime.now() - cache_time < timedelta(hours=1):
        with open(cache_file, 'rb') as f:
            return pickle.load(f)
```

#### Streamlit ìºì‹±
- **@st.cache_resource**: ì „ì—­ ê°ì²´ ìºì‹± (ë°ì´í„° ë§¤ë‹ˆì €, ì—”ì§„ë“¤)
- **@st.cache_data**: ë°ì´í„° ê²°ê³¼ ìºì‹±

### ë©”ëª¨ë¦¬ ìµœì í™”

#### ë°ì´í„° íƒ€ì… ìµœì í™”
```python
# ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° íƒ€ì… ì‚¬ìš©
df['Volume'] = df['Volume'].astype('int32')
df['Close'] = df['Close'].astype('float32')
```

#### ì²­í¬ ì²˜ë¦¬
```python
# ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬
def process_large_dataset(df, chunk_size=10000):
    for chunk in pd.read_csv(file, chunksize=chunk_size):
        yield process_chunk(chunk)
```

### ê³„ì‚° ìµœì í™”

#### ë²¡í„°í™” ì—°ì‚°
```python
# ë°˜ë³µë¬¸ ëŒ€ì‹  ë²¡í„°í™” ì—°ì‚° ì‚¬ìš©
factor_values = np.dot(X.values, importances)  # ë²¡í„°í™”
# ëŒ€ì‹  for loop ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
```

#### ë³‘ë ¬ ì²˜ë¦¬
```python
# scikit-learn ëª¨ë¸ì˜ n_jobs í™œìš©
model = RandomForestRegressor(n_estimators=100, n_jobs=-1)
```

## ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### ì•ˆì „í•œ ìˆ˜ì‹ ì‹¤í–‰

#### AST ê¸°ë°˜ íŒŒì‹±
```python
class SafeExpressionEvaluator:
    # í—ˆìš©ëœ ì—°ì‚°ìë§Œ ì‹¤í–‰
    ALLOWED_OPS = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        # ...
    }
    
    def _validate_ast(self, node):
        # ìœ„í—˜í•œ êµ¬ë¬¸ ì°¨ë‹¨
        if isinstance(node, (ast.Import, ast.ImportFrom)):
            raise ValueError("Import êµ¬ë¬¸ì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
```

#### ì…ë ¥ ê²€ì¦
```python
def _validate_formula(self, formula: str) -> bool:
    # í—ˆìš©ëœ ë¬¸ìë§Œ ì‚¬ìš©
    allowed_chars = set('abcdefghijklmnopqrstuvwxyz...')
    if not all(c in allowed_chars for c in formula.replace(' ', '')):
        return False
    
    # ìœ„í—˜í•œ í‚¤ì›Œë“œ ê²€ì‚¬
    dangerous_keywords = ['import', 'exec', 'eval', '__']
    if any(keyword in formula.lower() for keyword in dangerous_keywords):
        return False
```

### API í‚¤ ê´€ë¦¬

#### í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©
```python
# .env íŒŒì¼ì„ í†µí•œ ì•ˆì „í•œ API í‚¤ ê´€ë¦¬
from dotenv import load_dotenv
load_dotenv()

api_key = os.getenv('GEMINI_API_KEY')
```

#### í‚¤ ê²€ì¦
```python
def validate_api_key(api_key: str) -> bool:
    # API í‚¤ í˜•ì‹ ê²€ì¦
    if not api_key or len(api_key) < 20:
        return False
    return True
```

### ë°ì´í„° ë³´ì•ˆ

#### ì…ë ¥ ë°ì´í„° ê²€ì¦
```python
def validate_input_data(df: pd.DataFrame) -> bool:
    # í•„ìˆ˜ ì»¬ëŸ¼ í™•ì¸
    required_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    if not all(col in df.columns for col in required_columns):
        return False
    
    # ë°ì´í„° íƒ€ì… í™•ì¸
    numeric_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
    for col in numeric_columns:
        if not pd.api.types.is_numeric_dtype(df[col]):
            return False
    
    return True
```

## í™•ì¥ ê°€ì´ë“œ

### ìƒˆë¡œìš´ ë°ì´í„° ì†ŒìŠ¤ ì¶”ê°€

#### 1. ë°ì´í„° ì–´ëŒ‘í„° ìƒì„±
```python
class AlphaVantageAdapter:
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    def get_stock_data(self, symbol: str) -> pd.DataFrame:
        # Alpha Vantage API í˜¸ì¶œ ë¡œì§
        pass
```

#### 2. ë°ì´í„° ë§¤ë‹ˆì € í™•ì¥
```python
class DataManager:
    def __init__(self, data_sources: Dict[str, Any] = None):
        self.data_sources = data_sources or {'yahoo': YahooFinanceAdapter()}
    
    def add_data_source(self, name: str, adapter: Any):
        self.data_sources[name] = adapter
```

### ìƒˆë¡œìš´ íŒ©í„° ì¶”ê°€

#### 1. ì»¤ìŠ¤í…€ íŒ©í„° í´ë˜ìŠ¤
```python
class CustomFactor:
    def __init__(self, name: str, formula: str):
        self.name = name
        self.formula = formula
    
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        # íŒ©í„° ê³„ì‚° ë¡œì§
        pass
```

#### 2. íŒ©í„° ë ˆì§€ìŠ¤íŠ¸ë¦¬
```python
class FactorRegistry:
    def __init__(self):
        self.factors = {}
    
    def register_factor(self, factor: CustomFactor):
        self.factors[factor.name] = factor
    
    def get_factor(self, name: str) -> CustomFactor:
        return self.factors.get(name)
```

### ìƒˆë¡œìš´ ML ëª¨ë¸ ì¶”ê°€

#### 1. ëª¨ë¸ ì¸í„°í˜ì´ìŠ¤
```python
from abc import ABC, abstractmethod

class MLFactorModel(ABC):
    @abstractmethod
    def fit(self, X: pd.DataFrame, y: pd.Series) -> None:
        pass
    
    @abstractmethod
    def predict(self, X: pd.DataFrame) -> np.ndarray:
        pass
```

#### 2. êµ¬ì²´ì  ëª¨ë¸ êµ¬í˜„
```python
class LightGBMFactor(MLFactorModel):
    def __init__(self, **params):
        self.model = lgb.LGBMRegressor(**params)
    
    def fit(self, X: pd.DataFrame, y: pd.Series) -> None:
        self.model.fit(X, y)
    
    def predict(self, X: pd.DataFrame) -> np.ndarray:
        return self.model.predict(X)
```

### UI ì»´í¬ë„ŒíŠ¸ ì¶”ê°€

#### 1. ìƒˆë¡œìš´ í˜ì´ì§€ ì¶”ê°€
```python
def render_new_feature_page():
    st.header("ğŸ†• ìƒˆë¡œìš´ ê¸°ëŠ¥")
    
    # í˜ì´ì§€ ë¡œì§ êµ¬í˜„
    pass

# ë©”ì¸ ì•±ì—ì„œ ë©”ë‰´ ì¶”ê°€
selected_menu = option_menu(
    menu_title="ë©”ë‰´",
    options=["ë°ì´í„° ê´€ë¦¬", "AI íŒ©í„° ì¶”ì²œ", "íŒ©í„° ìƒì„±", "ë°±í…ŒìŠ¤íŒ…", "íŒ©í„° ë™ë¬¼ì›", "ìƒˆë¡œìš´ ê¸°ëŠ¥", "ì„¤ì •"],
    # ...
)

if selected_menu == "ìƒˆë¡œìš´ ê¸°ëŠ¥":
    render_new_feature_page()
```

#### 2. ì»¤ìŠ¤í…€ ì»´í¬ë„ŒíŠ¸
```python
def custom_metric_card(title: str, value: str, delta: str = None):
    """ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸"""
    html = f"""
    <div class="metric-card">
        <h3>{title}</h3>
        <p class="metric-value">{value}</p>
        {f'<p class="metric-delta">{delta}</p>' if delta else ''}
    </div>
    """
    st.markdown(html, unsafe_allow_html=True)
```

## ë°°í¬ ë° ìš´ì˜

### ë¡œì»¬ ë°°í¬
```bash
# ê°œë°œ í™˜ê²½ ì‹¤í–‰
streamlit run app.py

# í”„ë¡œë•ì…˜ ëª¨ë“œ ì‹¤í–‰
streamlit run app.py --server.port 8501 --server.address 0.0.0.0
```

### Docker ë°°í¬
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8501

CMD ["streamlit", "run", "app.py", "--server.address", "0.0.0.0"]
```

### í´ë¼ìš°ë“œ ë°°í¬

#### Streamlit Cloud
1. GitHub ì €ì¥ì†Œì— ì½”ë“œ í‘¸ì‹œ
2. Streamlit Cloudì—ì„œ ì•± ì—°ê²°
3. í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (secrets.toml)

#### AWS/GCP/Azure
- Docker ì»¨í…Œì´ë„ˆë¡œ ë°°í¬
- ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •
- ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™

### ëª¨ë‹ˆí„°ë§

#### ë¡œê¹… ì„¤ì •
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)
```

#### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
```python
import time
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        logger.info(f"{func.__name__} ì‹¤í–‰ì‹œê°„: {end_time - start_time:.2f}ì´ˆ")
        return result
    return wrapper
```

## ë¬¸ì œ í•´ê²°

### ì¼ë°˜ì ì¸ ë¬¸ì œë“¤

#### 1. ë©”ëª¨ë¦¬ ë¶€ì¡±
**ì¦ìƒ**: OutOfMemoryError, ëŠë¦° ì‘ë‹µ
**í•´ê²°ì±…**:
- ë°ì´í„° ì²­í¬ ì²˜ë¦¬
- ë¶ˆí•„ìš”í•œ ì»¬ëŸ¼ ì œê±°
- ë°ì´í„° íƒ€ì… ìµœì í™”

#### 2. API í˜¸ì¶œ ì œí•œ
**ì¦ìƒ**: API ì—ëŸ¬, 429 Too Many Requests
**í•´ê²°ì±…**:
- ìš”ì²­ ê°„ê²© ì¡°ì ˆ
- ìºì‹± í™œìš©
- API í‚¤ ë¡œí…Œì´ì…˜

#### 3. íŒ©í„° ê³„ì‚° ì˜¤ë¥˜
**ì¦ìƒ**: NaN ê°’, ë¬´í•œê°’
**í•´ê²°ì±…**:
- ì…ë ¥ ë°ì´í„° ê²€ì¦
- ê²°ì¸¡ì¹˜ ì²˜ë¦¬
- ìˆ˜ì‹ ê²€ì¦ ê°•í™”

### ë””ë²„ê¹… ë„êµ¬

#### 1. ë¡œê·¸ ë¶„ì„
```python
# ìƒì„¸ ë¡œê¹… í™œì„±í™”
logging.getLogger().setLevel(logging.DEBUG)

# íŠ¹ì • ëª¨ë“ˆ ë¡œê¹…
logger = logging.getLogger('factor_engine')
logger.debug(f"íŒ©í„° ê³„ì‚° ì¤‘: {factor_name}")
```

#### 2. ë°ì´í„° ê²€ì¦
```python
def debug_dataframe(df: pd.DataFrame, name: str):
    logger.info(f"{name} ë°ì´í„°í”„ë ˆì„ ì •ë³´:")
    logger.info(f"  - í¬ê¸°: {df.shape}")
    logger.info(f"  - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {df.memory_usage(deep=True).sum() / 1024**2:.2f} MB")
    logger.info(f"  - ê²°ì¸¡ì¹˜: {df.isnull().sum().sum()}")
    logger.info(f"  - ë°ì´í„° íƒ€ì…: {df.dtypes.value_counts().to_dict()}")
```

## ê¸°ì—¬ ê°€ì´ë“œ

### ì½”ë“œ ìŠ¤íƒ€ì¼
- PEP 8 ì¤€ìˆ˜
- Type hints ì‚¬ìš©
- Docstring ì‘ì„± (Google ìŠ¤íƒ€ì¼)

### í…ŒìŠ¤íŠ¸ ì‘ì„±
```python
def test_new_feature():
    """ìƒˆë¡œìš´ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"""
    # Given
    test_data = create_test_data()
    
    # When
    result = new_feature(test_data)
    
    # Then
    assert result is not None
    assert len(result) > 0
```

### Pull Request ê°€ì´ë“œ
1. Feature branch ìƒì„±
2. í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì‹¤í–‰
3. ë¬¸ì„œ ì—…ë°ì´íŠ¸
4. PR ìƒì„± ë° ë¦¬ë·° ìš”ì²­

---

ì´ ê¸°ìˆ  ë¬¸ì„œëŠ” ì•ŒíŒŒ íŒ©í„° ìƒì„±ê¸° v2.0ì˜ ë‚´ë¶€ êµ¬ì¡°ì™€ í™•ì¥ ë°©ë²•ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤. ì¶”ê°€ ì§ˆë¬¸ì´ë‚˜ ê°œì„  ì‚¬í•­ì´ ìˆìœ¼ë©´ ì–¸ì œë“ ì§€ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.

